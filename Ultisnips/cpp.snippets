snippet inp "include cpp"
#include <${1:iostream>}
endsnippet

snippet fora " for auto ptr"
for(auto ${1:ptr} : ${2:vector}){
    std::cout<< $1 << std::endl ;
}
endsnippet

snippet usi "using namespace"
using namespace ${1:std};
endsnippet

snippet sort " for auto ptr"
sort(${1:a}.begin(),$1.end());
endsnippet


snippet find " for auto ptr"
find(${1:a}.begin(),$1.end(),${2:1});
endsnippet

snippet forj "for loop"
for(int ${1:i}=0; $1 != ${2:count}; $1++){

}
endsnippet

snippet gtest "gtest framework"
#include <iostream>
#include <gtest/gtest.h>

TEST(${1:testName},${2:testNum}){

}

int main(int argc, char *argv[])
{
    testing::InitGoogleTest(&argc,argv);
    return RUN_ALL_TESTS();
}

endsnippet

post_jump "if snip.tabstop == 0 : split_line(snip.tabstops[4].current_text)"
snippet walkarray "遍历数组"
for(int i=0;i<${1:Row};i++){
    for(int j=0;j<${2:Col};j++){
        if(rand()%2){
            *((int*)${3:Array} +i*$2 + j) = 0;
        }
    }
}
endsnippet

snippet little_endian "check if the system is little_endian"
union {
    int i;
    char c[sizeof(int)];
} x;

x.i = 0x0001;
// big endian
// | 00000001 | 00000002 | 00000003 |0000004 |
// |        0 |        0 |        0 |      1 |
//
// little endian
// | 00000001 | 00000002 | 00000003 |0000004 |
// |        1 |        0 |        0 |      0 |

//little_endian
if(x.c[0] == 1){
    ${1://TODO}
}
endsnippet

snippet cerr " std::cerr output "
std::cerr << ${1} << std::endl;
endsnippet

snippet process_bar "status process bar"
// 让输出可以重新被覆盖
std::cout << "\e[A";
endsnippet

snippet /* "the doxygen brief 中英语"
/// * @brief ${1:brief comments}
/// * ${2:the full story}
endsnippet

snippet // "the doxygen comment"
/**
\if english
<pre>
${1:the english comment about this block}
</pre>
\else
<pre>
${2: 中文注释}
</pre>
\endif
         */
endsnippet

snippet singleton " to generate a singleton"

#include<iostream>
#include<mutex>

/// singleton class ${1:singleton}
class $1 {
    public:
        static $1 * getInstance(){
            if (instance == NULL) {
                objmutex.lock();
                if(instance == NULL ){
                    instance = new $1();
                }
                objmutex.unlock();
            }
            return instance;
        };
    private:
        /// >>>> deconstructor
        ~$1(){

        }
        /// >>>> constructor
        $1(){

        }
        /// >>>> ensure the singleton being freed by c++ compiler
        class globalgc{
            public:
                ~globalgc(){
                    if (instance) {
                        delete instance;
                    }
                }
        };

        static globalgc gc_obj;
        static std::mutex objmutex;
        static $1* instance;

};

$1::globalgc $1::gc_obj;
std::mutex $1::objmutex;
$1 *  $1::instance = NULL ;

endsnippet
